#!/usr/bin/env -S node --enable-source-maps
import { writeFileSync } from 'fs';
import * as path from 'path';
import * as url from 'url';
import OpenAI from 'openai';

import 'dotenv/config.js';

import Env from 'server/src/config/Env.ts';
import type { CordDotComCachedEmbedding } from 'common/types/index.ts';
import parseDownToPlaintextStrings from 'docs/lib/parseDownToPlaintext.ts';

const PAGES_TO_IGNORE = new Set(['https://cord.com/server']);

const MAX_EMBEDDING_TEXT_LENGTH = 20000;

const openai = new OpenAI({
  apiKey: Env.OPENAI_API_SECRET,
});

async function createEmbedding(input: string) {
  return await openai.embeddings.create({
    model: 'text-embedding-ada-002',
    input,
  });
}

function getTitleByFuglyRegex(txt: string): string {
  const titleTag = txt.match(/<title>([^<]*)<\/title>/);
  if (!titleTag) {
    throw new Error('Could not find any loc tags in the sitemap?');
  }

  return titleTag[1];
}

async function getChunkedSitePages(): Promise<
  { url: string; title: string; plaintext: string }[]
> {
  const res = await fetch('https://cord.com/sitemap.xml');

  const rawXML = await res.text();

  // Yes, I could tediously parse and traverse the XML with a proper XML parser.
  // Also I'm going to die some day and I that's not an accolade I want to etch
  // in my tombstone.  So instead, I'm just dumb-parsing it and moving on.
  const locTags = rawXML.match(/<loc>[^<]*<\/loc>/g);
  if (!locTags) {
    throw new Error('Could not find any loc tags in the sitemap?');
  }
  const locs = locTags
    .map((locTag) => locTag.substring(5, locTag.length - 6))
    .filter((loc) => !PAGES_TO_IGNORE.has(loc));

  const chunks: { url: string; title: string; plaintext: string }[] = [];
  const promises: Promise<void>[] = [];
  for (const locUrl of locs) {
    promises.push(
      (async () => {
        const pageResponse = await fetch(locUrl);
        const txt = await pageResponse.text();
        const plaintexts = parseDownToPlaintextStrings(txt);
        let title = getTitleByFuglyRegex(txt) || 'Cord.com';
        if (title.includes('Cord | Make the internet multiplayer | ')) {
          title = title.replace('Cord | Make the internet multiplayer | ', '');
        }
        for (const plaintext of plaintexts) {
          chunks.push({
            url: locUrl,
            title,
            plaintext,
          });
        }
      })(),
    );
  }
  await Promise.all(promises);
  return chunks;
}

const main = async () => {
  const chunks = await getChunkedSitePages();
  const embeddings: CordDotComCachedEmbedding[] = [];
  const promises: Array<Promise<void>> = [];
  for (const chunk of chunks) {
    const embedding: CordDotComCachedEmbedding = {
      url: chunk.url,
      embedding: undefined,
      plaintext: chunk.plaintext,
      title: chunk.title,
    };
    embeddings.push(embedding);
    promises.push(
      (async () => {
        if (chunk.plaintext.length > MAX_EMBEDDING_TEXT_LENGTH) {
          console.error(
            'Truncating very long plaintext chunk for page: ' + chunk.url,
          );
          console.error('Plaintext chunk is: ' + chunk.plaintext);
          process.exit(1);
        }
        try {
          const data = await createEmbedding(chunk.plaintext);
          embedding.embedding = data;
        } catch (e) {
          console.error(
            'Failed to fetch embedding for chunk: ' + chunk.plaintext,
          );
          console.error((e as Error).message);
        }
      })(),
    );
  }

  await Promise.all(promises);

  const embeddingsFile = `// @generated by scripts/cord-dot-com-generate-search-data.ts
import type { CordDotComCachedEmbedding } from 'common/types/index.ts';

const embeddings: CordDotComCachedEmbedding[] = ${JSON.stringify(
    embeddings,
    null,
    2,
  )};

export default embeddings;\n`;
  writeFileSync(
    path.join(
      path.dirname(url.fileURLToPath(import.meta.url)),
      '../../docs/server/searchData/CordDotComEmbeddings.ts',
    ),
    embeddingsFile,
  );
};

Promise.resolve(main()).catch((err) => {
  console.error(err);
  process.exit(1);
});
